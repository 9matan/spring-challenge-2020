
#define _CRT_SECURE_NO_WARNINGS
#define _SCL_SECURE_NO_WARNINGS


#include <chrono>
#include <ctime>
#include <string>
class CTimeProfiler{public:CTimeProfiler(char const* const name);~CTimeProfiler();private:std::string m_name;decltype(std::chrono::high_resolution_clock::now()) m_startTime;};
#ifndef DISABLE_PROFILE
#define PROFILE_TIME(name) CTimeProfiler timeProfiler(name);
#else
#define PROFILE_TIME(name)
#endif 

namespace SC2020{struct SOutputCommand;std::string ToString(SOutputCommand const& cmd);}

#include <algorithm>
#include <assert.h>
template<typename TComponent>struct SVec2Base{static const size_t ms_vecSize = 2;using ValueType = TComponent;template<typename TOtherComponent>explicit SVec2Base(SVec2Base<TOtherComponent> const other): m_x(static_cast<TComponent>(other[0])), m_y(static_cast<TComponent>(other[1])){}template<typename TOtherComponent>SVec2Base(TOtherComponent const x, TOtherComponent const y): m_x(static_cast<TComponent>(x)), m_y(static_cast<TComponent>(y)){}template<typename TOtherComponent>SVec2Base(std::initializer_list<TOtherComponent> const& data){assert(data.size() <= ms_vecSize);std::transform(data.begin(), data.end(), m_data,[](TOtherComponent const otherComp){return static_cast<TComponent>(otherComp);});}SVec2Base() : m_x(0), m_y(0) {}SVec2Base(TComponent const x, TComponent const y) : m_x(x), m_y(y) {}SVec2Base(std::initializer_list<TComponent> const& data){assert(data.size() <= ms_vecSize);std::copy(data.begin(), data.end(), m_data);}inline SVec2Base& operator=(SVec2Base const other) { m_data[0] = other.m_data[0]; m_data[1] = other.m_data[1]; return *this; }inline bool operator==(SVec2Base const other) const { return other[0] == m_data[0] && other[1] == m_data[1]; }inline bool operator!=(SVec2Base const other) const { return !(*this == other); }inline TComponent operator[](size_t const index) const { return m_data[index]; }inline TComponent& operator[](size_t const index) { return m_data[index]; }inline SVec2Base operator+(SVec2Base const other) const { return SVec2Base(m_data[0] + other.m_data[0], m_data[1] + other.m_data[1]); }inline SVec2Base operator-(SVec2Base const other) const { return SVec2Base(m_data[0] - other.m_data[0], m_data[1] - other.m_data[1]); }inline bool operator<(SVec2Base const other) const { if (m_data[0] == other[0]) { return m_data[1] < other[1]; } return m_data[0] < other[0]; }private:union{struct{TComponent m_x;TComponent m_y;};TComponent m_data[ms_vecSize];};};using SVec2i = SVec2Base<int>;using SVec2u = SVec2Base<unsigned int>;using SVec2si = SVec2Base<short>;using SVec2su = SVec2Base<unsigned short>;using SVec2 = SVec2Base<char>;
template<typename T, size_t TSize>class CVectorInPlace{public:CVectorInPlace() : m_nxtSlotIndex(0) {}CVectorInPlace(size_t const size) { resize(size); }CVectorInPlace(std::initializer_list<T> const& items){reserve(items.size());std::copy(items.begin(), items.end(), begin());}inline void push_back(T const& elem) { assert(m_nxtSlotIndex < TSize); m_data[m_nxtSlotIndex++] = elem; }template<typename ... TArgs>inline T& emplace_back(TArgs&& ... args) { m_data[m_nxtSlotIndex++] = std::move(T(std::forward<TArgs>(args)...)); return back(); }inline void pop_back() { m_nxtSlotIndex--; }inline T& back() { return m_data[m_nxtSlotIndex - 1]; }inline T& front() { return *m_data; }inline size_t size() const { return m_nxtSlotIndex; }inline void resize(size_t const capacity) { m_nxtSlotIndex = capacity; }inline void reserve(size_t const capacity) { assert(capacity <= TSize); }inline size_t max_capacity() const { return TSize; }inline bool is_full() const { return m_nxtSlotIndex >= TSize; }void erase_swap(T* const iter){size_t const index = std::distance(m_data, iter);std::swap(m_data[index], m_data[m_nxtSlotIndex - 1]);pop_back();}inline bool empty() const { return m_nxtSlotIndex == 0; }inline void clear() { m_nxtSlotIndex = 0; }inline T* begin() { return m_data; }inline T* end() { return m_data + m_nxtSlotIndex; }inline T const* begin() const { return m_data; }inline T const* end() const { return m_data + m_nxtSlotIndex; }inline T& operator[](size_t const index) { return m_data[index]; }inline T const& operator[](size_t const index) const { return m_data[index]; }private:size_t m_nxtSlotIndex = 0;T m_data[TSize];};

#include <memory>
#include <vector>
namespace SC2020{struct SMap;class CNavmesh;struct SBotData{std::unique_ptr<SMap> m_map;std::unique_ptr<CNavmesh> m_navmesh;std::vector<SVec2> m_superPelletPos;};}
constexpr int MAX_PLAYERS_CNT = 2;constexpr int MAX_PACS_CNT_PER_PLAYER = 5;constexpr int MAX_MAP_WIDTH = 35;constexpr int MAX_MAP_HEIGHT = 17;constexpr int MAX_MAP_AREA = MAX_MAP_WIDTH * MAX_MAP_HEIGHT;constexpr int MAX_COMMANDS_PER_PAC = 1;constexpr int MAX_OUTPUT_COMMANDS_CNT = MAX_PACS_CNT_PER_PLAYER * MAX_COMMANDS_PER_PAC;
namespace SC2020{enum class ECommandType{Move = 0,Speed};struct SOutputCommand{ECommandType m_commandType;int m_pacId;int m_x;int m_y;};}
namespace SC2020{struct SOutputData{CVectorInPlace<SOutputCommand, MAX_OUTPUT_COMMANDS_CNT> m_commands;};}
namespace SC2020{struct SInitInputData;struct SInputData;class CBot{public:CBot(SInitInputData const& initInData);~CBot();SOutputData FirstUpdate(SInputData const& inData);SOutputData Update(SInputData const& inData);private:CVectorInPlace<SVec2, MAX_MAP_AREA> m_floorCells;SBotData m_data;};}
namespace SC2020{struct SInputDataMap{int m_width;int m_height;std::vector<std::string> m_rows;};}
namespace SC2020{struct SInputDataPac{int m_pacId;int m_x;int m_y;int m_speedTurnsLeft;int m_abilityCooldown;std::string m_typeId;bool m_isMine;};struct SInputDataPellet{int m_x;int m_y;int m_value;};struct SInputData{int m_myScore;int m_opponentScore;std::vector<SInputDataPac> m_visiblePacs;std::vector<SInputDataPellet> m_visiblePellets;};struct SInitInputData{SInputDataMap m_map;};}

#include <iostream>
using namespace SC2020;using namespace std;void ReadInitInData(SInitInputData& data){cin >> data.m_map.m_width >> data.m_map.m_height; cin.ignore();cerr << data.m_map.m_width << " " << data.m_map.m_height << "\n";data.m_map.m_rows.resize(data.m_map.m_height);for(auto& row: data.m_map.m_rows){getline(cin, row);cerr << row << "\n";}}void ReadInData(SInputData& data){cin >> data.m_myScore >> data.m_opponentScore; cin.ignore();{int vissiblePacCount;cin >> vissiblePacCount; cin.ignore();data.m_visiblePacs.resize(vissiblePacCount);for (auto& pacData : data.m_visiblePacs){cin >> pacData.m_pacId>> pacData.m_isMine>> pacData.m_x >> pacData.m_y>> pacData.m_typeId>> pacData.m_speedTurnsLeft>> pacData.m_abilityCooldown;cin.ignore();}}{int vissiblePelletCnt;cin >> vissiblePelletCnt; cin.ignore();data.m_visiblePellets.resize(vissiblePelletCnt);for (auto& pelletData : data.m_visiblePellets){cin >> pelletData.m_x >> pelletData.m_y>> pelletData.m_value;cin.ignore();}}}void PrintOutData(SOutputData const& data){static string outputStr;outputStr.clear();for (auto const& cmd : data.m_commands){outputStr += ToString(cmd) + "|";}outputStr.pop_back();printf("%s\n", outputStr.c_str());}int main(){SInitInputData initInData;initInData.m_map.m_rows.reserve(MAX_MAP_HEIGHT);SInputData inData;inData.m_visiblePellets.reserve(MAX_MAP_AREA);inData.m_visiblePacs.reserve(MAX_PLAYERS_CNT * MAX_PACS_CNT_PER_PLAYER);CTimeProfiler profiler("FirstTurn");ReadInitInData(initInData);SC2020::CBot bot(initInData);ReadInData(inData);auto const outData = bot.FirstUpdate(inData);PrintOutData(outData);profiler.~CTimeProfiler();while (true){PROFILE_TIME("Update");ReadInData(inData);auto const outData = bot.Update(inData);PrintOutData(outData);}return 0;}

#define _CRT_SECURE_NO_WARNINGS

#include <array>
unsigned int InitializeRandom();unsigned int GetRandomUInt(unsigned int const minVal, unsigned int const maxVal);template<typename TIter>TIter GetRandomItem(TIter first, TIter last){size_t const rangeSize = static_cast<size_t>(last - first);return first + GetRandomUInt(0, static_cast<unsigned int>(rangeSize));}template<typename TEnum>TEnum GetRandomEnumValue(){return static_cast<TEnum>(GetRandomUInt(0, static_cast<unsigned int>(TEnum::Count)));}

#include <istream>
#include <ostream>
template <typename TVec>inline int GetDistanceL1(TVec const lhs, TVec const rhs) { return abs(static_cast<int>(lhs[0] - rhs[0])) + abs(static_cast<int>(lhs[1] - rhs[1])); }char const* ToString(SVec2i const vec2);std::ostream& operator<<(std::ostream& out, SVec2i const& vec);std::istream& operator>>(std::istream& in, SVec2i& vec);
namespace SC2020{struct SCell{CVectorInPlace<SVec2, 4> m_adjacentCells;float m_pelletScore = 0.0f;};}
template <typename TElem, size_t TMaxWidth, size_t TMaxHeight>struct SGrid2DInPlace{public:SGrid2DInPlace(size_t const width, size_t const height): m_width(width), m_height(height){assert(width <= TMaxWidth && height <= TMaxHeight);m_elements.resize(width * height);}inline TElem const& GetElement(SVec2 const pos) const { return m_elements[GetIndex(pos)]; }inline TElem& GetElement(SVec2 const pos) { return m_elements[GetIndex(pos)]; }inline size_t GetWidth() const { return m_width; }inline size_t GetHeight() const { return m_height; }inline size_t GetSize() const { return m_elements.size(); }inline bool IsValid(SVec2 const pos) const { return pos[0] >= 0 && pos[0] < m_width && pos[1] >= 0 && pos[1] < m_height; }inline size_t GetIndex(SVec2 const pos) const { return pos[0] + pos[1] * m_width; }inline TElem* begin() { return m_elements.begin(); }inline TElem* end() { return m_elements.end(); }inline TElem const* begin() const { return m_elements.begin(); }inline TElem const* end() const { return m_elements.end(); }private:CVectorInPlace<TElem, TMaxWidth * TMaxHeight> m_elements;size_t m_width;size_t m_height;};
namespace SC2020{template<typename TElem>using SGameGrid2D = SGrid2DInPlace<TElem, MAX_MAP_WIDTH, MAX_MAP_HEIGHT>;}
namespace SC2020{struct SMap : public SGameGrid2D<SCell>{public:using SGameGrid2D<SCell>::SGameGrid2D;inline SCell const& GetCell(SVec2 const pos) const { return GetElement(pos); }inline SCell& GetCell(SVec2 const pos) { return GetElement(pos); }};}
namespace SC2020{struct SInputDataMap;SMap BuildMap(SInputDataMap const& inDataMap);CVectorInPlace<SVec2, MAX_MAP_AREA> GetVisibleCells(SMap const& map, SVec2 const origin);}
namespace SC2020{struct SNavmeshEdge{using Path = std::vector<SVec2>;Path m_path;SVec2 GetAPos() const { return m_path.front(); }SVec2 GetBPos() const { return m_path.back(); }};}
namespace SC2020{struct SNavmeshNode{CVectorInPlace<short, 4> m_edgeIds;};}
namespace SC2020{struct SMap;struct SCell;class CNavmesh{public:CNavmesh(SMap const& map);CVectorInPlace<SNavmeshEdge::Path, 4> GetPathsToAdjacentNodes(SVec2 const pos) const;private:struct SNavmeshCell{SNavmeshNode m_node;short m_edgeId = -1;};private:SGameGrid2D<SNavmeshCell> m_navCells;CVectorInPlace<SNavmeshEdge, MAX_MAP_AREA> m_edges;private:void BuildNavmesh(SMap const& map);void BuildPathToNextNode(SMap const& map, SVec2 const from, SVec2 const to, SNavmeshEdge::Path& path);short AddEdge(SNavmeshEdge::Path const& path);};}

#define RNG(container)  container.begin(), container.end()
using namespace std;namespace SC2020{namespace{template<typename TIter>TIter FindClosestPos(TIter b, TIter e, SVec2 const origin){TIter curMin = b;for (TIter cur = b; cur != e; ++cur){if (GetDistanceL1(origin, *cur) < GetDistanceL1(origin, *curMin)){curMin = cur;}}return curMin;}CVectorInPlace<SVec2, MAX_MAP_AREA> CollectFloorCells(SInputDataMap const& map){CVectorInPlace<SVec2, MAX_MAP_AREA> cells;int rIndx = 0;int cIndx = 0;for (auto const& row : map.m_rows){cIndx = 0;for (auto const cell : row){if (cell == ' '){cells.push_back({ cIndx, rIndx });}++cIndx;}++rIndx;}return cells;}inline bool IsSuperPellet(float const score) { return score > 1.0f; }vector<SVec2> GetSuperPelletPos(vector<SInputDataPellet> const& pellets){vector<SVec2> res;res.reserve(pellets.size());for (auto& pellet : pellets){if (IsSuperPellet((float)pellet.m_value)){res.push_back({ pellet.m_x, pellet.m_y });}}return res;}void UpdatePellets(SBotData& botData, SInputData const& inData){for (auto const pos : botData.m_superPelletPos){botData.m_map->GetCell(pos).m_pelletScore = 0.0f;}{for (auto const pacData : inData.m_visiblePacs){if (!pacData.m_isMine){continue;}SVec2 const pacPos(pacData.m_x, pacData.m_y);auto const visiblePos = GetVisibleCells(*botData.m_map, pacPos);for (auto const vPos : visiblePos){botData.m_map->GetCell(vPos).m_pelletScore = 0.0f;}}}for (auto const& pellet : inData.m_visiblePellets){SVec2 const pelletPos(pellet.m_x, pellet.m_y);botData.m_map->GetCell(pelletPos).m_pelletScore = (float)pellet.m_value;}for (size_t y = 0; y < botData.m_map->GetHeight(); ++y){for (size_t x = 0; x < botData.m_map->GetWidth(); ++x){cerr << (int)(botData.m_map->GetElement({ x, y }).m_pelletScore + 0.0001f) << " ";}cerr << "\n";}}}CBot::CBot(SInitInputData const& initInData){auto const seed = InitializeRandom();cerr << "Seed: " << seed << "\n";m_data.m_map = make_unique<SMap>(BuildMap(initInData.m_map));m_data.m_navmesh = make_unique<CNavmesh>(*m_data.m_map);m_floorCells = CollectFloorCells(initInData.m_map);random_shuffle(RNG(m_floorCells));}CBot::~CBot() {}SOutputData CBot::FirstUpdate(SInputData const& inData){m_data.m_superPelletPos = GetSuperPelletPos(inData.m_visiblePellets);return Update(inData);}SOutputData CBot::Update(SInputData const& inData){SOutputData output;UpdatePellets(m_data, inData);CVectorInPlace<SVec2, MAX_MAP_AREA> superPellets;CVectorInPlace<SVec2, MAX_MAP_AREA> pellets;for (auto const& pellet : inData.m_visiblePellets){if (pellet.m_value > 1){superPellets.push_back({ pellet.m_x , pellet.m_y });}}for (size_t y = 0; y < m_data.m_map->GetHeight(); ++y){for (size_t x = 0; x < m_data.m_map->GetWidth(); ++x){if (m_data.m_map->GetElement({x, y}).m_pelletScore > 0.001f){pellets.push_back({ x, y });}}}for (auto const& pac : inData.m_visiblePacs){if (!pac.m_isMine){continue;}SVec2 const pacPos(pac.m_x, pac.m_y);SVec2 moveTo(0, 0);if (!pellets.empty() || !superPellets.empty()){SVec2* moveToIter = !superPellets.empty()? FindClosestPos(RNG(superPellets), pacPos): FindClosestPos(RNG(pellets), pacPos);if (!superPellets.empty()){superPellets.erase_swap(moveToIter);}else{pellets.erase_swap(moveToIter);}moveTo = *moveToIter;}else{moveTo = *GetRandomItem(RNG(m_floorCells));}SOutputCommand cmd;cmd.m_commandType = ECommandType::Move;cmd.m_pacId = pac.m_pacId;cmd.m_x = moveTo[0];cmd.m_y = moveTo[1];output.m_commands.push_back(cmd);}return output;}}
using namespace std;namespace SC2020{namespace{bool IsMapCellNode(SCell const& cell){return cell.m_adjacentCells.size() != 2 && cell.m_adjacentCells.size() != 0;}}CNavmesh::CNavmesh(SMap const& map): m_navCells(map.GetWidth(), map.GetHeight()){BuildNavmesh(map);}CVectorInPlace<SNavmeshEdge::Path, 4> CNavmesh::GetPathsToAdjacentNodes(SVec2 const pos) const{CVectorInPlace<SNavmeshEdge::Path, 4> paths;auto const& navCell = m_navCells.GetElement(pos);auto const& edgeIds = navCell.m_node.m_edgeIds;if (!edgeIds.empty()){for (auto const edgeId : edgeIds){auto const& edge = m_edges[edgeId];auto const& edgePath = edge.m_path;if (edge.GetAPos() == pos){paths.emplace_back(edgePath.begin(), edgePath.end());}else{paths.emplace_back(edgePath.rbegin(), edgePath.rend());}}}else if (navCell.m_edgeId >= 0){auto const& edge = m_edges[navCell.m_edgeId];auto const& edgePath = edge.m_path;auto const posIter = find(edgePath.begin(), edgePath.end(), pos);SNavmeshEdge::Path edgePath1(edgePath.begin(), posIter);reverse(edgePath1.begin(), edgePath1.end());SNavmeshEdge::Path const edgePath2(posIter + 1, edgePath.end());paths.push_back(edgePath1);paths.push_back(edgePath2);}return paths;}void CNavmesh::BuildNavmesh(SMap const& map){SNavmeshEdge::Path path;path.reserve(MAX_MAP_AREA);for(int x = 0; x < map.GetWidth(); ++x){for (int y = 0; y < map.GetHeight(); ++y){auto const pos = SVec2(x, y);auto const& mapCell = map.GetCell({ x, y });if (!IsMapCellNode(mapCell)){continue;}for (auto const nextPos : mapCell.m_adjacentCells){if (m_navCells.GetElement(nextPos).m_edgeId < 0){path.clear();path.push_back(pos);BuildPathToNextNode(map, pos, nextPos, path);AddEdge(path);}}}}}void CNavmesh::BuildPathToNextNode(SMap const& map, SVec2 const from, SVec2 const to, SNavmeshEdge::Path& path){path.push_back(to);auto const& mapCell = map.GetElement(to);if (IsMapCellNode(mapCell)){return;}for (auto const nextPos : mapCell.m_adjacentCells){if (nextPos != from){BuildPathToNextNode(map, to, nextPos, path);}}}short CNavmesh::AddEdge(SNavmeshEdge::Path const& path){assert(path.size() > 1);for (auto const edgeId : m_navCells.GetElement(path.front()).m_node.m_edgeIds){auto const& nextEdgeIds = m_navCells.GetElement(path.back()).m_node.m_edgeIds;if (find(nextEdgeIds.begin(), nextEdgeIds.end(), edgeId) != nextEdgeIds.end()){return edgeId;}}short const edgeId = (short)m_edges.size();auto& edge = m_edges.emplace_back();for(auto iter = path.begin() + 1; iter != (path.end() - 1); ++iter){auto& cell = m_navCells.GetElement(*iter);cell.m_edgeId = edgeId;auto& cell2 = m_navCells.GetElement(*iter);auto t = cell2.m_edgeId;}edge.m_path = path;m_navCells.GetElement(edge.GetAPos()).m_node.m_edgeIds.push_back(edgeId);m_navCells.GetElement(edge.GetBPos()).m_node.m_edgeIds.push_back(edgeId);return edgeId;}}
using namespace std;namespace SC2020{array<SVec2, 4> const ADJACENT_MASKS = {SVec2(-1, 0), {1, 0}, {0, -1}, {0, 1}};SMap BuildMap(SInputDataMap const& inDataMap){SMap map(inDataMap.m_width, inDataMap.m_height);auto const rows = inDataMap.m_rows;for (size_t y = 0; y < inDataMap.m_height; ++y){for (size_t x = 0; x < inDataMap.m_width; ++x){if (inDataMap.m_rows[y][x] != ' '){continue;}auto& cell = map.GetCell({ x, y });cell.m_pelletScore = 1.0f;for (auto const mask : ADJACENT_MASKS){SVec2 newPos = mask + SVec2(x, y);if (newPos[1] >= 0 && newPos[1] < map.GetHeight()){if (newPos[0] < 0) newPos[0] += (SVec2::ValueType)map.GetWidth();if (newPos[0] >= map.GetWidth()) newPos[0] -= (SVec2::ValueType)map.GetWidth();if (inDataMap.m_rows[newPos[1]][newPos[0]] == ' '){cell.m_adjacentCells.push_back(newPos);}}}}}return map;}CVectorInPlace<SVec2, MAX_MAP_AREA> GetVisibleCells(SMap const& map, SVec2 const origin){CVectorInPlace<SVec2, MAX_MAP_AREA> result;result.push_back(origin);for (auto const lineDir : ADJACENT_MASKS){auto* curCell = &map.GetCell(origin);SVec2 nextPos = origin + lineDir;while (find(curCell->m_adjacentCells.begin(), curCell->m_adjacentCells.end(), nextPos) != curCell->m_adjacentCells.end()){result.push_back(nextPos);curCell = &map.GetCell(nextPos);nextPos = nextPos + lineDir;}}return result;}}
char const* ToString(SVec2i const vec2){static char buff[32];sprintf(buff, "{%i:%i}", vec2[0], vec2[1]);return buff;}std::ostream& operator<<(std::ostream& out, SVec2i const& vec){out << vec[0] << " " << vec[1];return out;}std::istream& operator>>(std::istream& in, SVec2i& vec){in >> vec[0] >> vec[1];return in;}
#include <random>
#include <time.h>
unsigned int InitializeRandom(){unsigned int const seed = (unsigned int)time(nullptr);srand(seed);return seed;}unsigned int GetRandomUInt(unsigned int const minVal, unsigned int const maxVal){assert(minVal < maxVal);unsigned int const range = maxVal - minVal;return rand() % range + minVal;}
namespace SC2020{std::string ToString(SOutputCommand const& cmd){char buff[256];switch (cmd.m_commandType){case ECommandType::Move:sprintf(buff, "MOVE %i %i %i", cmd.m_pacId, cmd.m_x, cmd.m_y);break;case ECommandType::Speed:sprintf(buff, "SPEED %i", cmd.m_pacId);break;default:assert(false);}return buff;}}
using namespace std;CTimeProfiler::CTimeProfiler(char const* const name): m_name(name), m_startTime(chrono::high_resolution_clock::now()){}CTimeProfiler::~CTimeProfiler(){auto const end = chrono::high_resolution_clock::now();double const executionTime = (double)chrono::duration_cast<chrono::nanoseconds>(end - m_startTime).count();cerr.precision(3);cerr << m_name << ": " << executionTime / 1000000.0 << fixed << " ms" << endl;}
